{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"executable markdonw  files","text":"<p><code>midgy</code> runs markdown  documents as python .</p> <p>\ud83e\udd14 imagine being able to run your <code>README.md</code> as code. you could run the following command</p> <pre><code>midgy README.md\n</code></pre> <p>and all your  is converted to valid , and off your go!</p>"},{"location":"#the-future-is-markdown","title":"\ud83d\udd2e the future is markdown","text":"<p>markdown has emerged is a common file format for documentutation. those just learning programming will bring rely on their language to read and write code. <code>midgy</code>s approach to literate programming leaves space  for both natural and programming languages to cooperate in a story. it brings flexibility and freedom to the composition of news ideas.<sup>1</sup></p>"},{"location":"#i-about-this-documentation","title":"\u2139\ufe0f about this documentation","text":"<p>this documentation describes:</p> <ul> <li>the midgy language specification describes how markdown is translated to python</li> <li>the midgy implementation describes the specifics of the python implementation.<sup>2</sup></li> <li>the midgy design describes the design constraints this work was developed under.</li> </ul> <ol> <li> <p>freedom is a feature of literate programming more generally. in different literate programming circles like <code>orgmode</code>, <code>rmarkdown</code>, <code>quarto</code>, <code>jupyter</code> we notice a common thread of joy in composing programs. we find these features are by design when we reference the original literate programming paper:\u00a0\u21a9</p> </li> <li> <p>this specific implementation is written in python, but there is a little holding others back from porting this to other languages.\u00a0\u21a9</p> </li> </ol>"},{"location":"design/","title":"the <code>midgy</code> design","text":"<p><code>midgy</code> is half of a literate programming implementation.  literate programming a programming  paradigm proposed by donald knuth in 1984 that elevates authoring programming to the level of literature. as literate programmers we strive for literary and computational elegance because surely no one wants to write an illiterate program.</p> <p>literate programming specifies multi-lingual documents that serve as both literate and programs. in this paper, two document translation are defined:</p> <ol> <li>tangle: refers to translating the document to code. </li> <li>weave: refers to translating the document to a view (eg. html, pdf)</li> </ol> <p><code>midgy</code> only tangles markdown to python; it is the complement to <code>pidgy</code> which adds opinions on weaving.</p>"},{"location":"design/#design-choices","title":"design choices","text":"<p>extends reverse retrieve obsolesce</p> <p>every literate programming implementation needs to make choice of document &amp; programming. </p> <p>the desire with <code>midgy</code> to allows authors to explore the new interface between code &amp; non-code. a place that has little been explored</p>"},{"location":"design/#markup-language","title":"markup language","text":"<p><code>midgy</code> uses markdown because: * it is inclusive of nearly all formal and programming languages * markdown rarely fails. it violates expectation. * it is a useful markdown with plain-text * it commonly taught and widely adopted in software circles. * CommonMark has version 1.0 and communities are adopting the convention.</p>"},{"location":"design/#programming-language","title":"programming language","text":"<p>pascal was chosen for the original literate programming implementation because of its influence in education. a similar argument can be made for the choice of python in <code>midgy</code>. computer programming for everybody was a strong foundation for python that promotes programming as a mass literacy. </p> <p>another way to measure pythons impact is using the TIOBE scale. this scale measures popularity among programmers because ignores a large swath of folks who don't program.</p>"},{"location":"design/#literacy","title":"literacy","text":""},{"location":"design/#design-goals","title":"design goals","text":"<ul> <li>line-for-line transformations</li> <li>make pseudocode real code</li> <li>cooperate with documentation systems</li> <li>customizable</li> <li>minimize changes to generate valid python</li> </ul>"},{"location":"design/#prior-art","title":"prior art","text":""},{"location":"design/#jupyter-notebooks","title":"jupyter notebooks","text":""},{"location":"design/#choice-of-markup-language-and-implementation","title":"choice of markup language and implementation","text":"<p>the tokenization step reuses machinery from the [<code>markdown_it</code>] project. this library was chosen because amongst other markdown parsers (eg. [<code>mistune</code>], [<code>mistletoe</code>], [<code>python-markdown</code>]) it is the only one to return line numbers. </p> <p>[<code>markdown_it</code>] it is a port of the popular markdown it javascript library. it appears reliable for the <code>parser</code> and <code>tokens</code> because:  * it is not innovating independently so we should expect a fairly stable api. * the plugin interface makes it possible to extend the markdown parser in consistent ways as we do for the <code>code_lexer</code>, <code>doctest_lexer</code> and <code>front_matter</code> lexer. * further, [<code>markdown_it</code>] has strong adoption specifically through documentation in <code>jupyter_book</code> and linting with <code>mdformat</code>. </p>"},{"location":"midgy/","title":"<code>midgy</code>","text":"<p><code>midgy</code> transforms markdown to python modules and scripts.</p>"},{"location":"midgy/#command-line-interface","title":"command line interface","text":"<pre><code>midgy README.md     # run a readme file as python\nmidgy run README.md     # run a readme file as python\nmidgy -m README     # run a readme file as python\n</code></pre> <pre><code>  &gt;&gt;&gt; from midgy.run import Markdown\n  &gt;&gt;&gt; with Markdown():\n  ...   import README\n  &gt;&gt;&gt; print(README)\n  &lt;module 'README' from '...README.md'&gt;\n</code></pre> <p><code>midgy</code> is one half of <code>pidgy</code>, together they bring literate programming and computing afforandances to [python] and [<code>IPython</code>]. <code>midgy</code> is only concerned with the half of literate programming that translates a document to compiled code. <code>midgy</code> has a small api:</p> <ul> <li><code>md_to_python</code> - a function that converts a markdown document to python</li> <li><code>Python</code> - a class that parses a markdown document and renders python</li> <li><code>midgy.run.Markdown</code> - is an <code>importnb</code> context manager that includes markdown documents when importing python modules.</li> </ul>"},{"location":"midgy/#tangling-literate-programs","title":"tangling literate programs","text":"<p>literate programming is paradigm that treats code as literate, and vice versa; documents are evaluated on their literary and computational qualities. there are two actions defined in the framework of literate programming:</p> <ol> <li>render    : the act of translating the document into a programming language    : <code>midgy</code> renders markdown to python</li> <li>weave    : the act of translating the document to a rendered format    : <code>pidgy</code> weaves markdown to html, pdf, or md through the <code>jinja2</code> template system.</li> </ol> <p><code>midgy</code> focuses only on the <code>render</code> actions, and is extended in <code>pidgy</code> which implements the weave action.</p>"},{"location":"midgy/#extending-the-lexical-analysis-of-commonmark-markdown","title":"extending the lexical analysis of CommonMark markdown","text":"<p><code>midgy</code> extends the commonmark spec to reflect some common conventions.</p> <ol> <li>shebang    : <code>midgy</code> documents are programs and may begin with a shebang.</li> <li>front matter    : can be included at the beginning of a document or after a shebang.    : either toml, json or yaml can be used</li> <li>doctest    : a literate programming convention for including tests in python strings</li> <li>code    : our code blocks are modified to be aware of doctests and include lexical diagnostics of the content</li> </ol>"},{"location":"midgy/#rendering-tokenized-commonmark-as-python","title":"rendering tokenized CommonMark as Python","text":"<p><code>midgy</code> translates markdown to python relative to indented code blocks. content between indented code blocks are wrapped a python block strings, and non-indented code blocks can be included in python programs. the translation from markdown to python is meant to require the fewest changes to have valid python code.</p> <p><code>midgy</code> goes to great lengths to generate a line-for-line translation of the markdown to python. the line-for-line translation improves the error handling experience when using non-python documents as modules.</p> <pre><code>  from sys import argv\n  print(argv)\n</code></pre>"},{"location":"language/","title":"the <code>midgy</code> language tests","text":"<p>this directory contains the language specification for <code>midgy</code>. the file</p>"},{"location":"language/#tests-structure","title":"tests structure","text":"<p>the markdown input is renderd and compared to the explicit markdown input.</p> <pre><code>*********************************************************\nshort paragraph description\n```markdown\na block or markdown source\n```\n\n```python\na block of python source\n```\n</code></pre> <pre><code>if __name__ == \"__main__\":\n    from pathlib import Path\n    HERE = Path(__file__).parent\n    import pytest\n    pytest.main(args=[str(HERE / \"test_language.py\")])\n</code></pre>"},{"location":"language/basics/","title":"midgy basics","text":""},{"location":"language/basics/#basic-markdown-to-python-translations","title":"basic markdown to python translations","text":"<p>there are 3 flavors of literate programming available in <code>midgy</code>.  we can interleave non-code with code found as:  1. indented code blocks 2. code fences with specific <code>info</code> content 3. indented doctests when the <code>include_doctest</code> flag is enabled</p>"},{"location":"language/basics/#tangling-code-with-indented-code-blocks","title":"tangling code with indented code blocks","text":"<p>the primary flavor of <code>midgy</code> literate programming uses indented code blocks. content in between indented code blocks is treated as python blocks strings. the samples below show some general interactions between non-code and indented code blocks.</p> <p>single markdown lines are single python strings</p> <pre><code>a single line line of markdown is a python string.\n</code></pre> <pre><code>\"\"\"a single line line of markdown is a python string.\"\"\";\n</code></pre> <p>the semi-colon is appended to trailing block strings to suppress their output.</p> <p>a block of markdown lines are python block strings</p> <pre><code>a paragraph with a list following:\n* list item 1\n* list item 2\n</code></pre> <pre><code>\"\"\"a paragraph with a list following:\n* list item 1\n* list item 2\"\"\";\n</code></pre> <p>0-3 indents are treated as non-code and represented as strings</p> <pre><code>   an indented markdown line\n</code></pre> <pre><code>\"\"\"   an indented markdown line\"\"\";\n</code></pre> <p>at least 4 indents are raw python code</p> <pre><code>    print(\"hello world\")\n</code></pre> <pre><code>print(\"hello world\")\n</code></pre> <p>more than 4 indents are raw python code</p> <pre><code>          print(\"hello world\")\n</code></pre> <pre><code>print(\"hello world\")\n</code></pre>"},{"location":"language/basics/#mixing-code-and-non-code-blocks","title":"mixing code and non-code blocks","text":"<p>we are only concerned with block level markdown tokens when transpiling to python. through this lens a document is a collection of code and non-code blocks. </p> <p>code before markdown requires a dedent and zero or more newlines</p> <pre><code>    x = \"code before markdown\"\na markdown paragraph after code\n</code></pre> <pre><code>x = \"code before markdown\"\n\"\"\"a markdown paragraph after code\"\"\";\n</code></pre> <p>code after markdown requires at least one new line</p> <pre><code>a markdown paragraph before code\n\n    x = \"code after markdown\"\n</code></pre> <pre><code>\"\"\"a markdown paragraph before code\"\"\"\n\nx = \"code after markdown\"\n</code></pre> <p>triple double-quotes indicate explicit strings with whitespace included</p> <pre><code>    \"\"\"\n\na markdown paragraph\nwith lines\n\n    \"\"\"\n</code></pre> <pre><code>\"\"\"\n\na markdown paragraph\nwith lines\n\n\"\"\"\n</code></pre> <p>triple single-quotes indicate explicit strings with whitespace included</p> <pre><code>    '''\n\na markdown paragraph\nwith lines\n\n    '''\n</code></pre> <pre><code>'''\n\na markdown paragraph\nwith lines\n\n'''\n</code></pre> <p>markdown following a colon block (function) is indented and is the docstring</p> <pre><code>        def f():\n\nthe docstring of the function f\n\n        print(f())\n</code></pre> <pre><code>def f():\n\n    \"\"\"the docstring of the function f\"\"\"\n\nprint(f())\n</code></pre> <p>markdown following a colon block (function) aligns to trailing code and is the docstring</p> <pre><code>        def f():\nthe docstring of the function f\n\n                        return 42\n</code></pre> <pre><code>def f():\n                \"\"\"the docstring of the function f\"\"\"\n\n                return 42\n</code></pre> <p>line continuations connect code to lines to markdown lines</p> <pre><code>            foo =\\\n\nline continuations assign this string to `foo`\n</code></pre> <pre><code>foo =\\\n\\\n\"\"\"line continuations assign this string to `foo`\"\"\";\n</code></pre> <p>line continuations remove whitespace when using explicit quotes</p> <pre><code>            foo = \"\"\"\\\n\n\nline continuations remove the whitespace\\\n\n            \"\"\".split()\n</code></pre> <pre><code>foo = \"\"\"\\\n\\\n\\\n\"\"\"line continuations remove the whitespace\"\"\"\\\n\\\n\"\"\".split()\n</code></pre> <p>markdown can be used as parameters in a function call.</p> <pre><code>    requests.get(\nhttps://api.github.com\n\n    )\n</code></pre> <pre><code>requests.get(\n\"\"\"https://api.github.com\"\"\"\n\n)\n</code></pre> <p>as parameters, markdown blocks can be manipulated with python</p> <pre><code>    urls = [url.lstrip(\"*\").lstrip() for url in \n* https://api.github.com\n* https://google.com\n\n        .splitlines()]\n</code></pre> <pre><code>urls = [url.lstrip(\"*\").lstrip() for url in \n\"\"\"* https://api.github.com\n* https://google.com\"\"\"\n\n    .splitlines()]\n</code></pre> <p>by default doctests are not included in code.</p> <pre><code>&gt;&gt;&gt; this is a blockquote\n... with a trailing paragraph\nand is not a doctest\n\n    &gt;&gt;&gt; assert 'this is a doctest\\\n    ... because it is indented'\n</code></pre> <pre><code>\"\"\"&gt;&gt;&gt; this is a blockquote\n... with a trailing paragraph\nand is not a doctest\n\n    &gt;&gt;&gt; assert \\'this is a doctest\\\n    ... because it is indented\\'\"\"\";\n</code></pre>"},{"location":"language/code_fences/","title":"code fences","text":"<p>+++ [py] include_code_fences = [\"python\", \"\"] +++</p>"},{"location":"language/code_fences/#tangling-code-with-indented-code-fences","title":"tangling code with indented code fences","text":"<p>fences are commented when code</p> <pre><code>```python\nprint(\"hello world\")\n```\n</code></pre> <pre><code># ```python\nprint(\"hello world\")\n# ```\n</code></pre>"},{"location":"language/container_blocks/","title":"IPython magics","text":""},{"location":"language/container_blocks/#transpiling-in-container-blocks","title":"transpiling in container blocks","text":"<p>blocks and lists make up commonmark's container blocks.</p> <p>lists are probably one of the most confusing syntactic features of midgy.</p> <p>lists are strings</p> <pre><code>* list item 1\n* list item 2\n</code></pre> <pre><code>\"\"\"* list item 1\n* list item 2\"\"\";\n</code></pre> <p>indented code requires and extra indents</p> <pre><code>* list item 1\n\n        code block\n* list item 2\n\n    list paragraph\n</code></pre> <pre><code>\"\"\"* list item 1\"\"\"\n\ncode block\n\"\"\"* list item 2\n\n    list paragraph\"\"\";\n</code></pre> <p>each level requires and extra code indent</p> <pre><code>* list item 1\n\n        code block\n    * nested list item 1\n\n            code block\n    * nested list item 2\n\n        list paragraph\n</code></pre> <pre><code>\"\"\"* list item 1\"\"\"\n\ncode block\n\"\"\"    * nested list item 1\"\"\"\n\n    code block\n    \"\"\"    * nested list item 2\n\n        list paragraph\"\"\";\n</code></pre>"},{"location":"language/doctest/","title":"doctests","text":"<p>+++ py.include_doctest = true py.include_indented_code = false +++</p>"},{"location":"language/doctest/#doctest","title":"doctest","text":"<p><code>include_doctest</code> flag includes doctest inputs in code</p> <pre><code>    &gt;&gt;&gt; print(\"a doctest\")\n    a doctest\n</code></pre> <pre><code>print(\"a doctest\")\n# a doctest\n</code></pre> <p>doctests can contain magics</p> <pre><code>    &gt;&gt;&gt; %%python\n    ... print(\"a doctest\")\n    a doctest\n</code></pre> <pre><code>get_ipython().run_cell_magic('python', '',\n\"\"\"print(\"a doctest\")\"\"\")\n# a doctest\n</code></pre> <p>doctests can contain magics</p> <pre><code>+++\npy.include_indented_code = true\n+++\n    \"normal code and doctest code are separated\"\n\n    &gt;&gt;&gt; print(\"a doctest\")\n    a doctest\n</code></pre> <pre><code>locals().update(__import__(\"midgy\").front_matter.load(\"\"\"+++\npy.include_indented_code = true\n+++\"\"\"))\n\"normal code and doctest code are separated\"\n\nprint(\"a doctest\")\n# a doctest\n</code></pre>"},{"location":"language/doctest/#using-explicit-doctest-for-literate-programming","title":"using explicit <code>doctest</code> for literate programming","text":"<p>it is possible to program in doctests.  </p>"},{"location":"language/flags/","title":"<code>midgy</code> python language flags","text":"<p>flags provide control over the markdown to python translation. flags control the rendering of: * front matter * doctests * indented code * code fences * docstring</p> <p>indented code can be ignored</p> <pre><code>+++\npy.include_indented_code = false\n+++\n    ignored\n</code></pre> <pre><code>locals().update(__import__(\"midgy\").front_matter.load(\"\"\"+++\npy.include_indented_code = false\n+++\"\"\"))\n\"\"\"    ignored\"\"\";\n</code></pre> <p>markdown code can be ignored</p> <pre><code>+++\npy.include_markdown = false\n+++\nignored\n</code></pre> <pre><code>locals().update(__import__(\"midgy\").front_matter.load(\"\"\"+++\npy.include_markdown = false\n+++\"\"\"))\n# ignored\n</code></pre> <p>front matter code can be ignored</p> <pre><code>+++\npy.include_front_matter = false\n+++\n</code></pre> <pre><code># +++\n# py.include_front_matter = false\n# +++\n</code></pre>"},{"location":"language/front_matter/","title":"front matter","text":""},{"location":"language/front_matter/#front-matter","title":"front matter","text":"<p><code>midgy</code> permits <code>yaml</code> and <code>toml</code> front matter.</p> <p>triple + indicates toml front matter</p> <pre><code>+++\n+++\n</code></pre> <pre><code>locals().update(__import__(\"midgy\").front_matter.load(\"\"\"+++\n+++\"\"\"))\n</code></pre> <p>triple - indicates yaml front matter</p> <pre><code>---\n---\n</code></pre> <pre><code>locals().update(__import__(\"midgy\").front_matter.load(\"\"\"---\n---\"\"\"))\n</code></pre> <p>only shebang tokens can precede front matter</p> <pre><code>#!/usr/bin/env midgy\n---\n---\n</code></pre> <pre><code>#!/usr/bin/env midgy\nlocals().update(__import__(\"midgy\").front_matter.load(\"\"\"---\n---\"\"\"))\n</code></pre> <p>non-shebang tokens cancel front matter</p> <pre><code>a short paragraph\n---\n---\n</code></pre> <pre><code>\"\"\"a short paragraph\n---\n---\"\"\";\n</code></pre> <p>exclude front matter from parsing</p> <pre><code>+++\n[py]\ninclude_front_matter = false\n+++\n</code></pre> <pre><code># +++\n# [py]\n# include_front_matter = false\n# +++\n</code></pre>"},{"location":"language/line_continuations/","title":"line continuations","text":"<p>line continuations can connect markdown and python blocks separated by whitespace</p> <p>markdown blocks continue to code blocks when ending with line continuations, whitespace is captured</p> <pre><code>a markdown paragraph can continues\\\n\n\n        .upper()\n</code></pre> <pre><code>\"\"\"a markdown paragraph can continues\"\"\"\\\n\\\n        \\\n.upper()\n</code></pre> <p>code block continuations implicitly connect markdown blocks</p> <pre><code>    foo =\\\n\nthis is a string\n</code></pre> <pre><code>foo =\\\n\\\n\"\"\"this is a string\"\"\";\n</code></pre> <p>continuations in the middle of markdown or code are translated explicitly</p> <pre><code>a markdown paragraph can continues\\\ninto this\n\n    x = \\\n    42\n</code></pre> <pre><code>\"\"\"a markdown paragraph can continues\\\ninto this\"\"\"\n\nx = \\\n42\n</code></pre>"},{"location":"language/magics/","title":"IPython magics","text":"<p>+++ py.include_doctest = true +++</p>"},{"location":"language/magics/#midgy-and-magics","title":"<code>midgy</code> and magics","text":"<p>cell magics only built in to the language as they provide macro features for code.</p> <p>magics can be in indented code</p> <pre><code>%%magic arguments\nthe body of the cell magic\nis quoted and indents are maintained\n</code></pre> <pre><code>get_ipython().run_cell_magic('magic', 'arguments',\n\"\"\"the body of the cell magic\nis quoted and indents are maintained\"\"\")\n</code></pre> <p>magics can be in code fences</p> <pre><code>```ipython\n%%magic arguments \nthe body \n```\n</code></pre> <pre><code># ```ipython\nget_ipython().run_cell_magic('magic', 'arguments', \n\"\"\"the body\"\"\") \n# ```\n</code></pre> <p>magics can be in doctests</p> <pre><code>    &gt;&gt;&gt; %%magic arguments \n    ... the body \n    some output\n</code></pre> <pre><code>get_ipython().run_cell_magic('magic', 'arguments', \n\"\"\"the body\"\"\") \n# some output\n</code></pre> <p>magics can exist in the fence info</p> <pre><code>```%%magic arguments \nthe body \n```\n</code></pre> <pre><code>get_ipython().run_cell_magic('magic', 'arguments', # ``` \n\"\"\"the body\"\"\") \n# ```\n</code></pre> <p>this form is not friendly in native markdown mode</p>"},{"location":"language/mixed/","title":"mixed code tokens","text":""},{"location":"language/mixed/#mixing-code-fences-and-indented-code","title":"mixing code fences and indented code","text":"<p>it is possible mix multiple flavors of code inputs with <code>midgy</code>. this document demonstrates the implications of mixing indented code, code fences, and doctests inputs.</p> <p>generally, it is suspected that an author or document will choose one mode for code input and stick to it. what follows are some of the outcomes of this choice.</p> <p>code fences are offset 4 spaces from indented code</p> <pre><code>    print(\"indented code\")\n```python\nprint(\"fenced code\")\n```\n</code></pre> <pre><code>    print(\"indented code\")\n# ```python\nprint(\"fenced code\")\n# ```\n</code></pre> <p>the offset of four is defined because of the indented code block commonmark specification.</p> <pre><code>    def an_indented_code_function():\n```python\n    print(\"encapsulated in the function\")\n```\n```python\nprint(\"NOT encapsulated in the function\")\n```\n</code></pre> <pre><code>def an_indented_code_function():\n    # ```python\n    print(\"encapsulated in the function\")\n    # ```\n# ```python\nprint(\"NOT encapsulated in the function\")\n# ```\n</code></pre> <p>because of the offset, the code fence needs to be indented to exist within the function defition.</p>"},{"location":"programs/command-line-with-typer/","title":"writing command line programs with <code>midgy</code> and <code>typer</code>","text":""}]}